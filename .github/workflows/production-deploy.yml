name: Stage 3 - Production Deployment

on:
  push:
    branches:
      - main

jobs:
  production-deployment:
    runs-on: ubuntu-latest

    env:
      RESOURCE_GROUP: teddysit722Week10
      AKS_NAME: aksteddy722Week10
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
      IMAGE_TAG: ${{ github.sha }}
      PROD_NAMESPACE: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME
          kubectl cluster-info

      - name: Create Production Namespace if not exists
        run: |
          kubectl create namespace $PROD_NAMESPACE || echo "Namespace exists"

      - name: Deploy Backend Services
        run: |
          for service in customer_service order_service product_service; do
            K8S_NAME=$(echo $service | sed 's/_/-/g')
            echo "üì¶ Deploying $service as $K8S_NAME to production"

            if [ -d "k8s/$service" ]; then
              kubectl apply -f k8s/$service/ -n $PROD_NAMESPACE
            else
              kubectl create deployment $K8S_NAME \
                --image=$ACR_LOGIN_SERVER/$service:$IMAGE_TAG \
                -n $PROD_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
              kubectl expose deployment $K8S_NAME \
                --port=80 --target-port=80 \
                --name=${K8S_NAME}-service \
                -n $PROD_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
            fi

            kubectl label deployment $K8S_NAME app=$K8S_NAME -n $PROD_NAMESPACE --overwrite

            # Update image safely, fallback if container name mismatch
            CONTAINER_NAME=$(kubectl get deployment $K8S_NAME -n $PROD_NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].name}')
            if [ -n "$CONTAINER_NAME" ]; then
              kubectl set image deployment/$K8S_NAME $CONTAINER_NAME=$ACR_LOGIN_SERVER/$service:$IMAGE_TAG -n $PROD_NAMESPACE
              echo "‚úÖ $service image updated"
            else
              echo "‚ö†Ô∏è No container found in $K8S_NAME, skipping image update"
            fi

          done

      - name: Deploy Frontend
        run: |
          echo "üì¶ Deploying frontend to production"
          if [ -d "k8s/frontend" ]; then
            kubectl apply -f k8s/frontend/ -n $PROD_NAMESPACE
          else
            kubectl create deployment frontend --image=$ACR_LOGIN_SERVER/frontend:$IMAGE_TAG -n $PROD_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
            kubectl expose deployment frontend --port=80 --target-port=80 --name=frontend-service -n $PROD_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
          fi
          kubectl label deployment frontend app=frontend -n $PROD_NAMESPACE --overwrite

          FRONTEND_CONTAINER=$(kubectl get deployment frontend -n $PROD_NAMESPACE -o jsonpath='{.spec.template.spec.containers[0].name}')
          if [ -n "$FRONTEND_CONTAINER" ]; then
            kubectl set image deployment/frontend $FRONTEND_CONTAINER=$ACR_LOGIN_SERVER/frontend:$IMAGE_TAG -n $PROD_NAMESPACE
            echo "‚úÖ Frontend image updated"
          else
            echo "‚ö†Ô∏è Frontend container not found, skipping image update"
          fi

      - name: Wait for Deployments
        run: |
          DEPLOYMENTS=$(kubectl get deployments -n $PROD_NAMESPACE -o jsonpath='{.items[*].metadata.name}')
          for dep in $DEPLOYMENTS; do
            echo "‚è≥ Waiting for $dep to be ready..."
            kubectl rollout status deployment/$dep -n $PROD_NAMESPACE --timeout=300s
            echo "‚úÖ $dep ready"
          done

      - name: Run Production Health Checks
        run: |
          echo "üß™ Running production health checks..."

          # Check frontend deployment availability
          kubectl wait --for=condition=available deployment/frontend -n $PROD_NAMESPACE --timeout=120s && \
          echo "‚úÖ Frontend deployment available" || echo "‚ö†Ô∏è Frontend not ready"

          # Check backend pods readiness
          for svc in customer-service order-service product-service; do
            POD=$(kubectl get pods -n $PROD_NAMESPACE -l app=$svc -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            if [ -n "$POD" ]; then
              kubectl wait --for=condition=ready pod/$POD -n $PROD_NAMESPACE --timeout=120s
              echo "‚úÖ $svc pod ready"
            else
              echo "‚ö†Ô∏è $svc pod not found"
            fi
          done
