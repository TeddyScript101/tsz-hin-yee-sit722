name: Stage 3 - Production Deployment

on:
  push:
    branches:
      - main

jobs:
  production-deployment:
    runs-on: ubuntu-latest

    env:
      RESOURCE_GROUP: teddysit722Week10
      AKS_NAME: aksteddy722Week10
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
      IMAGE_TAG: ${{ github.sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME
          kubectl cluster-info

      - name: Create Production Namespace
        run: |
          kubectl create namespace production || echo "Namespace exists"

      - name: Create ACR Pull Secret
        run: |
          kubectl create secret docker-registry acr-auth \
            --docker-server=${{ secrets.ACR_LOGIN_SERVER }} \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace=production \
            --dry-run=client -o yaml | kubectl apply -f -

      # Apply ConfigMaps and Secrets
      - name: Apply ConfigMaps
        run: kubectl apply -f k8s/configmaps.yaml -n production

      - name: Apply Secrets
        run: kubectl apply -f k8s/secrets.yaml -n production

      - name: Deploy RabbitMQ
        run: |
          kubectl apply -f k8s/rabbitmq.yaml -n production
          kubectl rollout status deployment/rabbitmq-deployment-w10-aks -n production --timeout=300s

      # Deploy databases
      - name: Deploy Product DB
        run: |
          kubectl apply -f k8s/product-db.yaml -n production
          kubectl rollout status deployment/product-db-deployment-w10-aks -n production --timeout=300s

      - name: Deploy Order DB
        run: |
          kubectl apply -f k8s/order-db.yaml -n production
          kubectl rollout status deployment/order-db-deployment-w10-aks -n production --timeout=300s

      - name: Deploy Customer DB
        run: |
          kubectl apply -f k8s/customer-db.yaml -n production
          kubectl rollout status deployment/customer-db-deployment-w10-aks -n production --timeout=300s

      # Deploy services
      - name: Deploy Product Service
        run: |
          kubectl apply -f k8s/product-service.yaml -n production
          kubectl rollout status deployment/product-service-w10-aks -n production --timeout=300s

      - name: Deploy Order Service
        run: |
          kubectl apply -f k8s/order-service.yaml -n production
          kubectl rollout status deployment/order-service-w10-aks -n production --timeout=300s

      - name: Deploy Customer Service
        run: |
          kubectl apply -f k8s/customer-service.yaml -n production
          kubectl rollout status deployment/customer-service-w10-aks -n production --timeout=300s

      # Wait for Backend External IPs
      - name: Wait for Backend External IPs
        run: |
          get_ip() {
            local svc=$1
            local retries=30
            while [ $retries -gt 0 ]; do
              IP=$(kubectl get svc $svc -n production -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
              if [ ! -z "$IP" ]; then
                echo "$IP"
                return
              fi
              retries=$((retries - 1))
              echo "‚è≥ Waiting for $svc external IP... ($retries attempts left)"
              sleep 10
            done
            echo ""
          }

          PRODUCT_API_IP=$(get_ip product-service-w10-aks)
          ORDER_API_IP=$(get_ip order-service-w10-aks)
          CUSTOMER_API_IP=$(get_ip customer-service-w10-aks)

          if [ -z "$PRODUCT_API_IP" ] || [ -z "$ORDER_API_IP" ] || [ -z "$CUSTOMER_API_IP" ]; then
            echo "‚ùå One or more backend services do not have an external IP yet"
            exit 1
          fi

          echo "PRODUCT_API_IP=$PRODUCT_API_IP" >> $GITHUB_ENV
          echo "ORDER_API_IP=$ORDER_API_IP" >> $GITHUB_ENV
          echo "CUSTOMER_API_IP=$CUSTOMER_API_IP" >> $GITHUB_ENV

      # Inject backend IPs into frontend
      - name: Inject Backend IPs into Frontend main.js
        run: |
          sed -i "s|_PRODUCT_API_URL_|http://$PRODUCT_API_IP:8000|g" frontend/main.js
          sed -i "s|_ORDER_API_URL_|http://$ORDER_API_IP:8001|g" frontend/main.js
          sed -i "s|_CUSTOMER_API_URL_|http://$CUSTOMER_API_IP:8002|g" frontend/main.js

      # Login to ACR and build frontend image
      - name: Build and Push Frontend Image
        run: |
          echo ${{ secrets.ACR_PASSWORD }} | docker login -u ${{ secrets.ACR_USERNAME }} --password-stdin ${{ secrets.ACR_LOGIN_SERVER }}
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }} frontend
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }}

      # Deploy frontend using set image
      - name: Deploy Frontend
        run: |
          kubectl set image deployment/frontend-w10-aks frontend=${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }} -n production
          kubectl rollout status deployment/frontend-w10-aks -n production --timeout=300s

      # Display production status
      - name: Display Production Status
        run: |
          echo "üìã Production deployment summary:"
          kubectl get services -n production
          kubectl get deployments -n production
          kubectl get pods -n production

          for svc in frontend-w10-aks product-service-w10-aks order-service-w10-aks customer-service-w10-aks rabbitmq; do
            TYPE=$(kubectl get svc $svc -n production -o jsonpath='{.spec.type}' 2>/dev/null || echo "NotFound")
            if [ "$TYPE" = "LoadBalancer" ]; then
              EXTERNAL_IP=$(kubectl get svc $svc -n production -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              echo "‚úÖ $svc LoadBalancer IP: $EXTERNAL_IP"
            else
              echo "‚ÑπÔ∏è $svc is $TYPE"
            fi
          done

      # Health checks
      - name: Verify Backend, Frontend, and RabbitMQ Health
        run: |
          get_frontend_ip() {
            local svc=frontend-w10-aks
            kubectl get svc $svc -n production -o jsonpath='{.status.loadBalancer.ingress[0].ip}'
          }
          FRONTEND_IP=$(get_frontend_ip)

          check_health() {
            local name=$1
            local ip=$2
            local port=$3
            local url="http://$ip:$port/health"

            retries=10
            while [ $retries -gt 0 ]; do
              STATUS=$(curl -s -o /dev/null -w "%{http_code}" $url || echo "000")
              if [ "$STATUS" -eq 200 ]; then
                echo "‚úÖ $name is healthy at $url"
                return 0
              fi
              echo "‚è≥ Waiting for $name to be healthy... ($retries attempts left)"
              sleep 5
              retries=$((retries - 1))
            done

            echo "‚ùå $name failed health check at $url"
            exit 1
          }

          check_health "Product Service" $PRODUCT_API_IP 8000
          check_health "Order Service" $ORDER_API_IP 8001
          check_health "Customer Service" $CUSTOMER_API_IP 8002
          check_health "Frontend" $FRONTEND_IP 80
          check_health "RabbitMQ" localhost 15672
