name: Stage 3 - Production Deployment

on:
  push:
    branches:
      - main

jobs:
  production-deployment:
    runs-on: ubuntu-latest

    env:
      RESOURCE_GROUP: teddysit722Week10
      AKS_NAME: aksteddy722Week10
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
      IMAGE_TAG: "latest" # Use latest tag instead of commit SHA

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME
          kubectl cluster-info

      - name: Create production Namespace
        run: |
          kubectl create namespace production || echo "Namespace exists"

      - name: Deploy Backend Services
        run: |
          for service in customer_service order_service product_service; do
            K8S_NAME=$(echo $service | sed 's/_/-/g')
            echo "üì¶ Deploying $service as $K8S_NAME"
            
            kubectl create deployment $K8S_NAME \
              --image=$ACR_LOGIN_SERVER/$service:$IMAGE_TAG \
              -n production --dry-run=client -o yaml | kubectl apply -f -
            kubectl expose deployment $K8S_NAME \
              --port=80 --target-port=80 \
              --name=${K8S_NAME}-service \
              -n production --dry-run=client -o yaml | kubectl apply -f -

            kubectl label deployment $K8S_NAME app=$K8S_NAME -n production --overwrite
            kubectl set image deployment/$K8S_NAME *=$ACR_LOGIN_SERVER/$service:$IMAGE_TAG -n production

            echo "‚úÖ $service deployed and labeled"
          done

      - name: Get Backend IPs
        run: |
          PRODUCT_API_IP=$(kubectl get svc product-service -n production -o jsonpath='{.spec.clusterIP}')
          ORDER_API_IP=$(kubectl get svc order-service -n production -o jsonpath='{.spec.clusterIP}')
          CUSTOMER_API_IP=$(kubectl get svc customer-service -n production -o jsonpath='{.spec.clusterIP}')

          echo "PRODUCT_API_IP=$PRODUCT_API_IP" >> $GITHUB_ENV
          echo "ORDER_API_IP=$ORDER_API_IP" >> $GITHUB_ENV
          echo "CUSTOMER_API_IP=$CUSTOMER_API_IP" >> $GITHUB_ENV

          echo "‚úÖ Captured backend IPs"

      - name: Inject Backend IPs into Frontend main.js
        run: |
          echo "Injecting backend IPs into frontend/main.js"
          sed -i "s|_PRODUCT_API_URL_|http://$PRODUCT_API_IP:80|g" frontend/main.js
          sed -i "s|_ORDER_API_URL_|http://$ORDER_API_IP:80|g" frontend/main.js
          sed -i "s|_CUSTOMER_API_URL_|http://$CUSTOMER_API_IP:80|g" frontend/main.js

          echo "--- Modified main.js (first 30 lines) ---"
          head -30 frontend/main.js
          echo "---------------------------------"

      - name: Deploy Frontend
        run: |
          echo "üì¶ Deploying frontend"
          kubectl create deployment frontend --image=$ACR_LOGIN_SERVER/frontend:$IMAGE_TAG -n production --dry-run=client -o yaml | kubectl apply -f -
          kubectl expose deployment frontend --port=80 --target-port=80 --name=frontend-service -n production --dry-run=client -o yaml | kubectl apply -f -
          kubectl set image deployment/frontend *=$ACR_LOGIN_SERVER/frontend:$IMAGE_TAG -n production
          kubectl label deployment frontend app=frontend -n production --overwrite
          echo "‚úÖ Frontend deployed and labeled"

      - name: Wait for Deployments
        run: |
          DEPLOYMENTS=$(kubectl get deployments -n production -o jsonpath='{.items[*].metadata.name}')
          for dep in $DEPLOYMENTS; do
            kubectl rollout status deployment/$dep -n production --timeout=300s
            echo "‚úÖ $dep ready"
          done

      - name: Run production Tests
        run: |
          echo "üß™ Running tests..."
          kubectl port-forward service/frontend-service 8080:80 -n production &
          PF_PID=$!
          sleep 10
          curl -f -s http://localhost:8080 && echo "‚úÖ Frontend responding" || echo "‚ö†Ô∏è Frontend not responding"
          kill $PF_PID 2>/dev/null || true

          for svc in customer-service order-service product-service; do
            POD=$(kubectl get pods -n production -l app=$svc -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
            if [ -n "$POD" ]; then
              kubectl wait --for=condition=ready pod/$POD -n production --timeout=120s
              echo "‚úÖ $svc pod ready"
            else
              echo "‚ö†Ô∏è $svc pod not found"
            fi
          done

      - name: Display Production Status
        run: |
          echo "üìã Production deployment summary:"
          kubectl get services -n production
          kubectl get deployments -n production
          kubectl get pods -n production
          echo "‚úÖ Production deployment completed!"
