name: Stage 3 - Production Deployment

on:
  push:
    branches:
      - main

jobs:
  production-deployment:
    runs-on: ubuntu-latest

    env:
      RESOURCE_GROUP: teddysit722Week10
      AKS_NAME: aksteddy722Week10
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
      IMAGE_TAG: ${{ github.sha }}  # Use commit SHA instead of "latest"

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME
          kubectl cluster-info

      - name: Create Production Namespace
        run: |
          kubectl create namespace production || echo "Namespace exists"

      # Apply ConfigMaps and Secrets
      - name: Apply ConfigMaps
        run: kubectl apply -f k8s/configmaps.yaml -n production

      - name: Apply Secrets
        run: kubectl apply -f k8s/secrets.yaml -n production

      # Deploy Databases
      - name: Deploy Product DB
        run: |
          kubectl apply -f k8s/product-db.yaml -n production
          kubectl rollout status deployment/product-db-deployment-w10-aks -n production --timeout=300s
          kubectl wait --for=condition=Ready pod -l app=product-db -n production --timeout=180s

      - name: Deploy Order DB
        run: |
          kubectl apply -f k8s/order-db.yaml -n production
          kubectl rollout status deployment/order-db-deployment-w10-aks -n production --timeout=300s
          kubectl wait --for=condition=Ready pod -l app=order-db -n production --timeout=180s

      - name: Deploy Customer DB
        run: |
          kubectl apply -f k8s/customer-db.yaml -n production
          kubectl rollout status deployment/customer-db-deployment-w10-aks -n production --timeout=300s
          kubectl wait --for=condition=Ready pod -l app=customer-db -n production --timeout=180s

      # Update image tags in YAML files
      - name: Update Image Tags
        run: |
          # Update product service image with proper tag
          sed -i "s|image: teddyacr722week10.azurecr.io/product_service:\${IMAGE_TAG}|image: ${{ secrets.ACR_LOGIN_SERVER }}/product_service:${{ env.IMAGE_TAG }}|g" k8s/product-service.yaml

          # Update order service image  
          sed -i "s|image: teddyacr722week10.azurecr.io/order_service:\${IMAGE_TAG}|image: ${{ secrets.ACR_LOGIN_SERVER }}/order_service:${{ env.IMAGE_TAG }}|g" k8s/order-service.yaml

          # Update customer service image
          sed -i "s|image: teddyacr722week10.azurecr.io/customer_service:\${IMAGE_TAG}|image: ${{ secrets.ACR_LOGIN_SERVER }}/customer_service:${{ env.IMAGE_TAG }}|g" k8s/customer-service.yaml

          # Update frontend image
          sed -i "s|image: teddyacr722week10.azurecr.io/frontend:\${IMAGE_TAG}|image: ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }}|g" k8s/frontend.yaml

          # Verify the substitutions
          echo "üîç Checking image tags in service files:"
          echo "Product Service:"
          grep "image:" k8s/product-service.yaml
          echo "Order Service:"
          grep "image:" k8s/order-service.yaml
          echo "Customer Service:"
          grep "image:" k8s/customer-service.yaml
          echo "Frontend:"
          grep "image:" k8s/frontend.yaml

      # Deploy Backend Services
      - name: Deploy Product Service
        run: |
          kubectl apply -f k8s/product-service.yaml -n production
          kubectl rollout status deployment/product-service-w10-aks -n production --timeout=300s
          kubectl wait --for=condition=Ready pod -l app=product-service -n production --timeout=180s

      - name: Deploy Order Service
        run: |
          kubectl apply -f k8s/order-service.yaml -n production
          kubectl rollout status deployment/order-service-w10-aks -n production --timeout=300s
          kubectl wait --for=condition=Ready pod -l app=order-service -n production --timeout=180s

      - name: Deploy Customer Service
        run: |
          kubectl apply -f k8s/customer-service.yaml -n production
          kubectl rollout status deployment/customer-service-w10-aks -n production --timeout=300s
          kubectl wait --for=condition=Ready pod -l app=customer-service -n production --timeout=180s

      # Inject Service URLs and Deploy Frontend
      - name: Inject Service URLs into Frontend
        run: |
          FRONTEND_FILE=frontend/main.js

          PRODUCT_API_IP="http://$(kubectl get svc product-service-w10-aks -n production -o jsonpath='{.status.loadBalancer.ingress[0].ip}'):8000"
          ORDER_API_IP="http://$(kubectl get svc order-service-w10-aks -n production -o jsonpath='{.status.loadBalancer.ingress[0].ip}'):8000"
          CUSTOMER_API_IP="http://$(kubectl get svc customer-service-w10-aks -n production -o jsonpath='{.status.loadBalancer.ingress[0].ip}'):8000"

          sed -i "s|_PRODUCT_API_URL_|${PRODUCT_API_IP}|g" "$FRONTEND_FILE"
          sed -i "s|_ORDER_API_URL_|${ORDER_API_IP}|g" "$FRONTEND_FILE"
          sed -i "s|_CUSTOMER_API_URL_|${CUSTOMER_API_IP}|g" "$FRONTEND_FILE"

      - name: Login to ACR
        run: |
          echo ${{ secrets.ACR_PASSWORD }} | docker login -u ${{ secrets.ACR_USERNAME }} --password-stdin ${{ secrets.ACR_LOGIN_SERVER }}

      - name: Build and Push Frontend
        run: |
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${IMAGE_TAG} frontend
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${IMAGE_TAG}

      - name: Deploy Frontend
        run: |
          kubectl apply -f k8s/frontend.yaml -n production
          kubectl rollout status deployment/frontend-w10-aks -n production --timeout=300s
          kubectl wait --for=condition=Ready pod -l app=frontend -n production --timeout=180s

      - name: Display Production Status
        run: |
          echo "üìã Production deployment summary:"
          kubectl get services -n production
          kubectl get deployments -n production
          kubectl get pods -n production
          
          for svc in frontend-w10-aks product-service-w10-aks order-service-w10-aks customer-service-w10-aks; do
            TYPE=$(kubectl get svc $svc -n production -o jsonpath='{.spec.type}' 2>/dev/null || echo "NotFound")
            if [ "$TYPE" = "LoadBalancer" ]; then
              EXTERNAL_IP=$(kubectl get svc $svc -n production -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              echo "‚úÖ $svc LoadBalancer IP: $EXTERNAL_IP"
            else
              echo "‚ÑπÔ∏è $svc is $TYPE"
            fi
          done
