name: Stage 2 - Staging Deployment

on:
  workflow_run:
    workflows: ["CI Pipeline - Testing Branch"]
    types:
      - completed
    branches:
      - testing

jobs:
  staging-deployment:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    env:
      RESOURCE_GROUP: teddysit722Week10
      AKS_NAME: aksteddy722Week10
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
      IMAGE_TAG: ${{ github.event.workflow_run.head_sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME
          kubectl cluster-info

      - name: Create Staging Namespace
        run: |
          STAGING_NAMESPACE="staging-${{ github.run_id }}"
          kubectl create namespace $STAGING_NAMESPACE || echo "Namespace exists"
          echo "STAGING_NAMESPACE=$STAGING_NAMESPACE" >> $GITHUB_ENV

      - name: Create ACR Pull Secret
        run: |
          kubectl create secret docker-registry acr-auth \
            --docker-server=${{ secrets.ACR_LOGIN_SERVER }} \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace=$STAGING_NAMESPACE

      # -------------------------------
      # Update service types for staging (ClusterIP)
      # -------------------------------
      - name: Update Service Types for Staging
        run: |
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/product-service.yaml
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/order-service.yaml  
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/customer-service.yaml
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/frontend.yaml

      - name: Apply ConfigMaps
        run: kubectl apply -f k8s/configmaps.yaml -n $STAGING_NAMESPACE

      - name: Apply Secrets
        run: kubectl apply -f k8s/secrets.yaml -n $STAGING_NAMESPACE

      # -------------------------------
      # Deploy Databases
      # -------------------------------
      - name: Deploy Product DB
        run: |
          kubectl apply -f k8s/product-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/product-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Order DB
        run: |
          kubectl apply -f k8s/order-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/order-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Customer DB
        run: |
          kubectl apply -f k8s/customer-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/customer-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Deploy RabbitMQ
      # -------------------------------
      - name: Deploy RabbitMQ
        run: |
          kubectl apply -f k8s/rabbitmq.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/rabbitmq-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Deploy Backend Services
      # -------------------------------
      - name: Deploy Product Service
        run: |
          kubectl apply -f k8s/product-service.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/product-service-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Order Service
        run: |
          kubectl apply -f k8s/order-service.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/order-service-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Customer Service
        run: |
          kubectl apply -f k8s/customer-service.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/customer-service-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Get Backend Cluster IPs
      # -------------------------------
      - name: Get Backend IPs
        run: |
          PRODUCT_API_IP=$(kubectl get svc product-service-w10-aks -n $STAGING_NAMESPACE -o jsonpath='{.spec.clusterIP}')
          ORDER_API_IP=$(kubectl get svc order-service-w10-aks -n $STAGING_NAMESPACE -o jsonpath='{.spec.clusterIP}')
          CUSTOMER_API_IP=$(kubectl get svc customer-service-w10-aks -n $STAGING_NAMESPACE -o jsonpath='{.spec.clusterIP}')

          echo "PRODUCT_API_IP=$PRODUCT_API_IP" >> $GITHUB_ENV
          echo "ORDER_API_IP=$ORDER_API_IP" >> $GITHUB_ENV
          echo "CUSTOMER_API_IP=$CUSTOMER_API_IP" >> $GITHUB_ENV

      # -------------------------------
      # Inject Backend IPs into Frontend main.js
      # -------------------------------
      - name: Inject Backend IPs
        run: |
          FRONTEND_FILE=frontend/main.js
          sed -i "s|_PRODUCT_API_URL_|http://$PRODUCT_API_IP:80|g" "$FRONTEND_FILE"
          sed -i "s|_ORDER_API_URL_|http://$ORDER_API_IP:80|g" "$FRONTEND_FILE"
          sed -i "s|_CUSTOMER_API_URL_|http://$CUSTOMER_API_IP:80|g" "$FRONTEND_FILE"

      # -------------------------------
      # Build and Push Frontend Image
      # -------------------------------
      - name: Login to ACR
        run: |
          echo ${{ secrets.ACR_PASSWORD }} | docker login -u ${{ secrets.ACR_USERNAME }} --password-stdin ${{ secrets.ACR_LOGIN_SERVER }}

      - name: Build and Push Frontend Image
        run: |
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }} frontend
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }}

      # -------------------------------
      # Update Frontend Deployment Image
      # -------------------------------
      - name: Update Frontend Deployment
        run: |
          kubectl apply -f k8s/frontend.yaml -n $STAGING_NAMESPACE
          kubectl set image deployment/frontend-w10-aks \
            frontend-container=${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }} \
            -n $STAGING_NAMESPACE
          kubectl rollout status deployment/frontend-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Manual Health Check
      # -------------------------------
      - name: Run Staging Health Checks
        run: |
          echo "🧪 Running health checks for backend services..."

          SERVICES=(
            "product-service-w10-aks:$PRODUCT_API_IP":8000
            "order-service-w10-aks:$ORDER_API_IP":8001
            "customer-service-w10-aks:$CUSTOMER_API_IP":8002
            "frontend-w10-aks:localhost:8080"
          )

          # Port-forward frontend for local testing
          kubectl port-forward service/frontend-w10-aks -n $STAGING_NAMESPACE 8080:80 &
          PF_PID=$!
          sleep 5

          for svc in "${SERVICES[@]}"; do
            NAME="${svc%%:*}"
            URL="http://${svc##*:}"
            echo "Checking $NAME at $URL"
            if curl -f -s --max-time 10 $URL >/dev/null; then
              echo "✅ $NAME is healthy"
            else
              echo "❌ $NAME is NOT responding"
            fi
          done

          kill $PF_PID 2>/dev/null || true

      # -------------------------------
      # Display Staging Status
      # -------------------------------
      - name: Display Staging Status
        run: |
          kubectl get services -n $STAGING_NAMESPACE
          kubectl get deployments -n $STAGING_NAMESPACE
          kubectl get pods -n $STAGING_NAMESPACE

      # -------------------------------
      # Cleanup Staging Environment
      # -------------------------------
      - name: Cleanup Staging Environment
        if: always()
        run: |
          kubectl delete namespace $STAGING_NAMESPACE --ignore-not-found=true --timeout=60s
