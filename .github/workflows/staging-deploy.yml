name: Stage 2 - Staging Deployment

on:
  workflow_run:
    workflows: ["CI Pipeline - Testing Branch"]
    types:
      - completed
    branches:
      - testing

jobs:
  staging-deployment:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    env:
      RESOURCE_GROUP: teddysit722Week10
      AKS_NAME: aksteddy722Week10
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
      IMAGE_TAG: ${{ github.event.workflow_run.head_sha }}
      STAGING_NAMESPACE: staging-${{ github.run_id }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME --overwrite-existing
          kubectl cluster-info

      - name: Create Staging Namespace
        run: |
          kubectl create namespace $STAGING_NAMESPACE || echo "Namespace $STAGING_NAMESPACE exists"
          echo "STAGING_NAMESPACE=$STAGING_NAMESPACE" >> $GITHUB_ENV

      - name: Create ACR Pull Secret
        run: |
          kubectl create secret docker-registry acr-auth \
            --docker-server=${{ secrets.ACR_LOGIN_SERVER }} \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace=$STAGING_NAMESPACE --dry-run=client -o yaml | kubectl apply -f -

      - name: Validate YAML Files
        run: |
          echo "üîç Validating Kubernetes YAML files..."
          for file in k8s/*.yaml; do
            if [ -f "$file" ]; then
              echo "Validating $file"
              kubectl apply -f "$file" --dry-run=client -n $STAGING_NAMESPACE || echo "‚ùå Validation failed for $file"
            fi
          done

      - name: Update Service Types and Add ImagePullSecrets
        run: |
          # Change LoadBalancer to ClusterIP for internal testing
          for service_file in k8s/product-service.yaml k8s/order-service.yaml k8s/customer-service.yaml k8s/frontend.yaml; do
            if [ -f "$service_file" ]; then
              sed -i 's/type: LoadBalancer/type: ClusterIP/g' "$service_file"
              echo "‚úÖ Updated service type in $service_file"
            fi
          done

          # Add imagePullSecrets to all service deployments
          for service_file in k8s/customer-service.yaml k8s/order-service.yaml k8s/product-service.yaml k8s/frontend.yaml; do
            if [ -f "$service_file" ]; then
              # Check if imagePullSecrets already exists
              if ! grep -q "imagePullSecrets:" "$service_file"; then
                # Add imagePullSecrets after spec: under template: spec:
                sed -i '/template:/,/spec:/!b; /spec:/a\      imagePullSecrets:\n      - name: acr-auth' "$service_file"
                echo "‚úÖ Added imagePullSecrets to $service_file"
              else
                echo "‚ÑπÔ∏è  imagePullSecrets already exists in $service_file"
              fi
            fi
          done

      - name: Apply ConfigMaps
        run: kubectl apply -f k8s/configmaps.yaml -n $STAGING_NAMESPACE

      - name: Apply Secrets
        run: kubectl apply -f k8s/secrets.yaml -n $STAGING_NAMESPACE

      # --- Databases ---
      - name: Deploy Product DB
        run: |
          kubectl apply -f k8s/product-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/product-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s
          kubectl wait --for=condition=available deployment/product-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Order DB
        run: |
          kubectl apply -f k8s/order-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/order-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s
          kubectl wait --for=condition=available deployment/order-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Customer DB
        run: |
          kubectl apply -f k8s/customer-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/customer-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s
          kubectl wait --for=condition=available deployment/customer-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # --- RabbitMQ ---
      - name: Deploy RabbitMQ
        run: |
          kubectl apply -f k8s/rabbitmq.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/rabbitmq-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s
          kubectl wait --for=condition=available deployment/rabbitmq-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s
          kubectl get svc rabbitmq-service-w10-aks -n $STAGING_NAMESPACE

      - name: Deploy All Services
        run: |
          # Define services with CORRECT repository names (using underscores as they exist in ACR)
          declare -A SERVICES=(
            ["product-service"]="product_service:product-service-container"
            ["order-service"]="order_service:order-service-container" 
            ["customer-service"]="customer_service:customer-service-container"
          )

          for SERVICE_FILE in "${!SERVICES[@]}"; do
            IFS=':' read -r IMAGE_NAME CONTAINER_NAME <<< "${SERVICES[$SERVICE_FILE]}"
            DEPLOYMENT_NAME="${SERVICE_FILE}-w10-aks"
            IMAGE="${{ secrets.ACR_LOGIN_SERVER }}/${IMAGE_NAME}:${{ env.IMAGE_TAG }}"

            echo "Deploying $SERVICE_FILE with repository $IMAGE_NAME"
            echo "Image: $IMAGE"
            echo "Deployment: $DEPLOYMENT_NAME, Container: $CONTAINER_NAME"
            
            # Verify image exists in ACR
            echo "üîç Verifying image exists in ACR..."
            az acr repository show --name teddyacr722week10 --image ${IMAGE_NAME}:${{ env.IMAGE_TAG }} || echo "‚ö†Ô∏è Image might not exist yet, but continuing..."
            
            # Apply the YAML file first
            kubectl apply -f k8s/${SERVICE_FILE}.yaml -n $STAGING_NAMESPACE
            
            # Set the image with correct container name
            kubectl set image deployment/$DEPLOYMENT_NAME $CONTAINER_NAME=$IMAGE -n $STAGING_NAMESPACE
            
            # Wait for rollout
            kubectl rollout status deployment/$DEPLOYMENT_NAME -n $STAGING_NAMESPACE --timeout=300s
            kubectl wait --for=condition=available deployment/$DEPLOYMENT_NAME -n $STAGING_NAMESPACE --timeout=300s
          done

      # --- Frontend - Build and Deploy ---
      - name: Login to ACR
        run: |
          echo ${{ secrets.ACR_PASSWORD }} | docker login -u ${{ secrets.ACR_USERNAME }} --password-stdin ${{ secrets.ACR_LOGIN_SERVER }}

      - name: Update Frontend Configuration for Cluster
        run: |
          # Create a copy of the frontend directory to avoid modifying the original
          cp -r frontend frontend-staging
          FRONTEND_FILE=frontend-staging/main.js

          # Update API URLs for internal cluster communication
          sed -i "s|_PRODUCT_API_URL_|http://product-service-w10-aks:8000|g" "$FRONTEND_FILE"
          sed -i "s|_ORDER_API_URL_|http://order-service-w10-aks:8001|g" "$FRONTEND_FILE"
          sed -i "s|_CUSTOMER_API_URL_|http://customer-service-w10-aks:8002|g" "$FRONTEND_FILE"

      - name: Build and Push Frontend Image
        run: |
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }} frontend-staging
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }}

      - name: Deploy Frontend
        run: |
          IMAGE="${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }}"
          kubectl apply -f k8s/frontend.yaml -n $STAGING_NAMESPACE
          kubectl set image deployment/frontend-w10-aks frontend-container=$IMAGE -n $STAGING_NAMESPACE
          kubectl rollout status deployment/frontend-w10-aks -n $STAGING_NAMESPACE --timeout=600s
          kubectl wait --for=condition=available deployment/frontend-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # --- Port-Forward for Testing ---
      - name: Setup Port Forwarding for Tests
        run: |
          # Port-forward services for health checks
          kubectl port-forward service/product-service-w10-aks 8000:8000 -n $STAGING_NAMESPACE &
          kubectl port-forward service/order-service-w10-aks 8001:8001 -n $STAGING_NAMESPACE &
          kubectl port-forward service/customer-service-w10-aks 8002:8002 -n $STAGING_NAMESPACE &
          kubectl port-forward service/frontend-w10-aks 8080:80 -n $STAGING_NAMESPACE &
          sleep 10  # Wait for port-forwards to establish

      # --- Health Checks ---
      - name: Retry Health Checks for Services
        run: |
          declare -A SERVICES=(
            ["product-service"]="http://localhost:8000/health"
            ["order-service"]="http://localhost:8001/health" 
            ["customer-service"]="http://localhost:8002/health"
            ["frontend"]="http://localhost:8080/"
          )

          for name in "${!SERVICES[@]}"; do
            url="${SERVICES[$name]}"
            RETRIES=5
            for i in $(seq 1 $RETRIES); do
              if curl -f -s --max-time 10 "$url" >/dev/null 2>&1; then
                echo "‚úÖ $name is ready (attempt $i/$RETRIES)"
                break
              else
                echo "‚è≥ $name not ready (attempt $i/$RETRIES), retrying in 5s..."
                sleep 5
                if [ $i -eq $RETRIES ]; then
                  echo "‚ùå $name health check failed after $RETRIES attempts"
                  # Use the correct label format
                  app_label=${name%-service}  # Remove -service suffix if present
                  if [ "$name" == "frontend" ]; then
                    app_label="frontend"
                  fi
                  kubectl logs -l app=$app_label -n $STAGING_NAMESPACE --tail=50 || echo "No logs available for app=$app_label"
                  exit 1
                fi
              fi
            done
          done

      - name: Check RabbitMQ Status
        run: |
          echo "üîç Basic RabbitMQ status check..."
          kubectl get pods -l app=rabbitmq -n $STAGING_NAMESPACE
          echo "‚úÖ RabbitMQ deployment check completed"

      # --- Deployment Summary ---
      - name: Deployment Summary
        run: |
          echo "üéâ Staging Deployment Summary"
          echo "=============================="
          echo "Namespace: $STAGING_NAMESPACE"
          echo "Cluster: $AKS_NAME"
          echo "Image Tag: $IMAGE_TAG"
          echo ""
          echo "üì¶ Deployed Services:"
          kubectl get deployments -n $STAGING_NAMESPACE
          echo ""
          echo "üîó Services:"
          kubectl get svc -n $STAGING_NAMESPACE
          echo ""
          echo "üîç Pods Status:"
          kubectl get pods -n $STAGING_NAMESPACE
          echo ""
          echo "‚úÖ All services deployed successfully to staging environment!"

      # --- Debug Information (if needed) ---
      - name: Collect Debug Information
        if: failure()
        run: |
          echo "üìã Collecting debug information..."
          echo "==================================="
          echo "Failed Pods:"
          kubectl get pods -n $STAGING_NAMESPACE | grep -v Running || true
          echo ""
          echo "Product Service Logs:"
          kubectl logs -l app=product-service -n $STAGING_NAMESPACE --tail=100 || true
          echo ""
          echo "Order Service Logs:"
          kubectl logs -l app=order-service -n $STAGING_NAMESPACE --tail=100 || true
          echo ""
          echo "Customer Service Logs:"
          kubectl logs -l app=customer-service -n $STAGING_NAMESPACE --tail=100 || true
          echo ""
          echo "Events:"
          kubectl get events -n $STAGING_NAMESPACE --sort-by='.lastTimestamp' | tail -20 || true

      # --- Cleanup ---
      - name: Cleanup Port Forwards
        if: always()
        run: |
          # Kill all port-forward processes
          pkill -f "kubectl port-forward" || true

      - name: Cleanup Namespace
        if: always()
        run: |
          echo "üßπ Cleaning up staging namespace..."
          kubectl delete namespace $STAGING_NAMESPACE --ignore-not-found=true --wait=false
