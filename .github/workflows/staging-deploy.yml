name: Stage 2 - Staging Deployment

on:
  workflow_run:
    workflows: ["CI Pipeline - Testing Branch"]
    types:
      - completed
    branches:
      - testing

jobs:
  staging-deployment:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    env:
      RESOURCE_GROUP: teddysit722Week10
      AKS_NAME: aksteddy722Week10
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
      IMAGE_TAG: ${{ github.event.workflow_run.head_sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME
          kubectl cluster-info

      - name: Create Staging Namespace
        run: |
          STAGING_NAMESPACE="staging-${{ github.run_id }}"
          kubectl create namespace $STAGING_NAMESPACE || echo "Namespace exists"
          echo "STAGING_NAMESPACE=$STAGING_NAMESPACE" >> $GITHUB_ENV

      - name: Create ACR Pull Secret
        run: |
          kubectl create secret docker-registry acr-auth \
            --docker-server=${{ secrets.ACR_LOGIN_SERVER }} \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace=$STAGING_NAMESPACE

      # -------------------------------
      # Update service types for staging (ClusterIP)
      # -------------------------------
      - name: Update Service Types for Staging
        run: |
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/product-service.yaml
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/order-service.yaml  
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/customer-service.yaml
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/frontend.yaml

      - name: Apply ConfigMaps
        run: kubectl apply -f k8s/configmaps.yaml -n $STAGING_NAMESPACE

      - name: Apply Secrets
        run: kubectl apply -f k8s/secrets.yaml -n $STAGING_NAMESPACE

      # -------------------------------
      # Deploy Databases
      # -------------------------------
      - name: Deploy Product DB
        run: |
          kubectl apply -f k8s/product-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/product-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Order DB
        run: |
          kubectl apply -f k8s/order-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/order-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Customer DB
        run: |
          kubectl apply -f k8s/customer-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/customer-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Deploy RabbitMQ
      # -------------------------------
      - name: Deploy RabbitMQ
        run: |
          kubectl apply -f k8s/rabbitmq.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/rabbitmq-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Deploy Backend Services
      # -------------------------------
      - name: Deploy Product Service
        run: |
          kubectl apply -f k8s/product-service.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/product-service-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Order Service
        run: |
          kubectl apply -f k8s/order-service.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/order-service-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Customer Service
        run: |
          kubectl apply -f k8s/customer-service.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/customer-service-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Deploy Frontend
      # -------------------------------
      - name: Update Frontend Configuration for Cluster
        run: |
          # Use cluster DNS names instead of localhost for proper cluster communication
          FRONTEND_FILE=frontend/main.js
          sed -i "s|_PRODUCT_API_URL_|http://product-service-w10-aks:8000|g" "$FRONTEND_FILE"
          sed -i "s|_ORDER_API_URL_|http://order-service-w10-aks:8001|g" "$FRONTEND_FILE"
          sed -i "s|_CUSTOMER_API_URL_|http://customer-service-w10-aks:8002|g" "$FRONTEND_FILE"

      - name: Login to ACR
        run: |
          echo ${{ secrets.ACR_PASSWORD }} | docker login -u ${{ secrets.ACR_USERNAME }} --password-stdin ${{ secrets.ACR_LOGIN_SERVER }}

      - name: Build and Push Frontend Image
        run: |
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }} frontend
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }}

      - name: Deploy Frontend
        run: |
          kubectl apply -f k8s/frontend.yaml -n $STAGING_NAMESPACE
          kubectl set image deployment/frontend-w10-aks \
            frontend-container=${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }} \
            -n $STAGING_NAMESPACE
          kubectl rollout status deployment/frontend-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Wait for Services and Test Internal Connectivity
      # -------------------------------
      - name: Wait for Services and Test Internal Connectivity
        run: |
          NAMESPACE=$STAGING_NAMESPACE

          echo "üîç Checking pod status..."
          kubectl get pods -n $NAMESPACE -o wide

          echo "‚úÖ All pods are running. Proceeding with connectivity tests..."

          # Instead of using kubectl wait, check pod status directly
          echo "üìä Verifying pod readiness..."
          ALL_READY=true
          PODS=$(kubectl get pods -n $NAMESPACE -o jsonpath='{.items[*].metadata.name}')

          for pod in $PODS; do
            STATUS=$(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.status.phase}')
            READY=$(kubectl get pod $pod -n $NAMESPACE -o jsonpath='{.status.containerStatuses[0].ready}')
            if [ "$STATUS" = "Running" ] && [ "$READY" = "true" ]; then
              echo "‚úÖ $pod: $STATUS and ready=$READY"
            else
              echo "‚ùå $pod: $STATUS, ready=$READY"
              ALL_READY=false
            fi
          done

          if [ "$ALL_READY" = "true" ]; then
            echo "üéâ All pods are ready! Proceeding with tests..."
          else
            echo "‚ö†Ô∏è Some pods are not ready, but continuing with tests..."
          fi

          echo "üîç Testing internal service connectivity..."

          # Simple direct test without complex setup
          echo "üîç Testing service endpoints directly..."

          SERVICES=(
            "product-service-w10-aks:8000"
            "order-service-w10-aks:8001"
            "customer-service-w10-aks:8002"
            "frontend-w10-aks:80"
          )

          for service in "${SERVICES[@]}"; do
            IFS=':' read -r svc port <<< "$service"
            name=${svc%-w10-aks}
            
            echo "üîç Testing $name..."
            
            # Test using kubectl exec from a random running pod
            if kubectl run quick-test --image=curlimages/curl:latest --rm -i --restart=Never -n $NAMESPACE -- \
              curl -f -s --max-time 10 "http://$svc:$port/health" >/dev/null 2>&1; then
              echo "‚úÖ $name is reachable"
            else
              echo "‚ö†Ô∏è $name may not be fully ready yet"
            fi
          done

          echo "üîç Comprehensive health check..."

          # Final health check using a single command
          kubectl run final-health-check --image=curlimages/curl:latest --rm -i --restart=Never -n $NAMESPACE -- \
            sh -c "
            echo '=== Service Health Check ==='
            echo 'Product Service:' && curl -s -o /dev/null -w '  HTTP %{http_code}\n' http://product-service-w10-aks:8000/health || echo '  ‚ùå Failed'
            echo 'Order Service:' && curl -s -o /dev/null -w '  HTTP %{http_code}\n' http://order-service-w10-aks:8001/health || echo '  ‚ùå Failed'
            echo 'Customer Service:' && curl -s -o /dev/null -w '  HTTP %{http_code}\n' http://customer-service-w10-aks:8002/health || echo '  ‚ùå Failed'
            echo 'Frontend:' && curl -s -o /dev/null -w '  HTTP %{http_code}\n' http://frontend-w10-aks:80/ || echo '  ‚ùå Failed'
            echo '=== Test Complete ==='
            "
      # -------------------------------
      # Test Service Health Endpoints
      # -------------------------------
      - name: Test Service Health Endpoints
        run: |
          NAMESPACE=$STAGING_NAMESPACE

          echo "üîç Testing service health endpoints..."

          # Test each service using kubectl port-forward temporarily
          SERVICES=(
            "product-service-w10-aks:8000:18000"
            "order-service-w10-aks:8001:18001"
            "customer-service-w10-aks:8002:18002" 
            "frontend-w10-aks:80:18003"
          )

          for service in "${SERVICES[@]}"; do
            IFS=':' read -r svc target_port local_port <<< "$service"
            name=${svc%-w10-aks}
            
            echo "üîç Testing $name..."
            
            # Start port forward in background
            kubectl port-forward svc/$svc $local_port:$target_port -n $NAMESPACE --address=127.0.0.1 > /dev/null 2>&1 &
            PF_PID=$!
            
            # Wait for port forward to establish
            sleep 5
            
            # Test the health endpoint with retry
            for i in {1..3}; do
              if curl -f -s --max-time 10 "http://localhost:$local_port/health" >/dev/null 2>&1; then
                echo "‚úÖ $name health endpoint is working (attempt $i/3)"
                RESPONSE=$(curl -s "http://localhost:$local_port/health" | head -c 100)
                echo "   Response: $RESPONSE"
                break
              else
                if [ $i -eq 3 ]; then
                  echo "‚ùå $name health endpoint failed after 3 attempts"
                  # Get logs for debugging
                  echo "üìÑ Last 10 lines of logs:"
                  kubectl logs -l app=$name -n $NAMESPACE --tail=10 2>/dev/null || echo "No logs available for $name"
                else
                  echo "‚è≥ $name health endpoint not ready (attempt $i/3), retrying..."
                  sleep 3
                fi
              fi
            done
            
            # Kill the port forward
            kill $PF_PID 2>/dev/null || true
            sleep 2
          done

      # -------------------------------
      # Comprehensive Logs Check
      # -------------------------------
      - name: Check Service Logs for Errors
        run: |
          NAMESPACE=$STAGING_NAMESPACE

          echo "üîç Checking service logs for errors..."

          PODS=$(kubectl get pods -n $NAMESPACE -o jsonpath='{.items[*].metadata.name}')

          for pod in $PODS; do
            echo "--- Checking $pod for errors ---"
            kubectl logs $pod -n $NAMESPACE --tail=50 | grep -i "error\|exception\|fail\|timeout" | head -5 || echo "No errors found in $pod"
          done

      # -------------------------------
      # Final Health Check
      # -------------------------------
      - name: Final Health Check
        run: |
          NAMESPACE=$STAGING_NAMESPACE

          echo "üîç Running final health checks..."

          # Test using kubectl exec from a temporary pod
          kubectl run health-check --image=curlimages/curl:latest --rm -i --restart=Never -n $NAMESPACE -- \
            sh -c "
            echo 'Testing internal service connectivity...'
            
            echo '1. Product Service:'
            curl -s -o /dev/null -w 'Status: %{http_code}\n' http://product-service-w10-aks:8000/health || echo 'Failed'
            
            echo '2. Order Service:'
            curl -s -o /dev/null -w 'Status: %{http_code}\n' http://order-service-w10-aks:8001/health || echo 'Failed'
            
            echo '3. Customer Service:'
            curl -s -o /dev/null -w 'Status: %{http_code}\n' http://customer-service-w10-aks:8002/health || echo 'Failed'
            
            echo '4. Frontend:'
            curl -s -o /dev/null -w 'Status: %{http_code}\n' http://frontend-w10-aks:80/ || echo 'Failed'
            
            echo '5. Testing service intercommunication:'
            echo '   Product -> DB: ' && curl -s http://product-service-w10-aks:8000/health | grep -o '\"database\":\"[^\"]*\"' || echo 'DB check failed'
            echo '   Order -> DB: ' && curl -s http://order-service-w10-aks:8001/health | grep -o '\"database\":\"[^\"]*\"' || echo 'DB check failed'
            echo '   Customer -> DB: ' && curl -s http://customer-service-w10-aks:8002/health | grep -o '\"database\":\"[^\"]*\"' || echo 'DB check failed'
            "

      # -------------------------------
      # RabbitMQ Health Check
      # -------------------------------
      - name: Check RabbitMQ Status
        run: |
          NAMESPACE=$STAGING_NAMESPACE

          echo "üîç Checking RabbitMQ status..."

          # Check if RabbitMQ pod is ready
          kubectl get pod -l app=rabbitmq -n $NAMESPACE

          # Check RabbitMQ logs for any connection issues
          echo "üìÑ RabbitMQ recent logs:"
          kubectl logs -l app=rabbitmq -n $NAMESPACE --tail=20 | grep -i "connection\|connected\|error" | tail -10 || echo "No relevant RabbitMQ logs found"

          # Test RabbitMQ connectivity from order service perspective
          echo "üîç Testing RabbitMQ connectivity from Order Service..."
          ORDER_POD=$(kubectl get pod -l app=order-service -n $NAMESPACE -o jsonpath='{.items[0].metadata.name}')
          kubectl exec $ORDER_POD -n $NAMESPACE -- \
            sh -c "nc -z rabbitmq-service-w10-aks 5672 && echo '‚úÖ RabbitMQ port 5672 is reachable' || echo '‚ùå RabbitMQ port 5672 not reachable'"

      # -------------------------------
      # Deployment Summary
      # -------------------------------
      - name: Deployment Summary
        run: |
          NAMESPACE=$STAGING_NAMESPACE

          echo "üéâ Staging Deployment Summary"
          echo "=============================="
          echo "Namespace: $NAMESPACE"
          echo "Cluster: $AKS_NAME"
          echo "Image Tag: $IMAGE_TAG"
          echo ""
          echo "üì¶ Deployed Services:"
          kubectl get deployments -n $NAMESPACE
          echo ""
          echo "üîó Services:"
          kubectl get svc -n $NAMESPACE
          echo ""
          echo "‚úÖ All services deployed successfully to staging environment!"
