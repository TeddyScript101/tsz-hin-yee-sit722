name: Stage 2 - Staging Deployment

on:
  workflow_run:
    workflows: ["CI Pipeline - Testing Branch"]
    types:
      - completed
    branches:
      - testing

jobs:
  staging-deployment:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    env:
      RESOURCE_GROUP: teddysit722Week10
      AKS_NAME: aksteddy722Week10
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
      IMAGE_TAG: ${{ github.event.workflow_run.head_sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME
          kubectl cluster-info

      - name: Create Staging Namespace
        run: |
          STAGING_NAMESPACE="staging-${{ github.run_id }}"
          kubectl create namespace $STAGING_NAMESPACE || echo "Namespace exists"
          echo "STAGING_NAMESPACE=$STAGING_NAMESPACE" >> $GITHUB_ENV

      - name: Create ACR Pull Secret
        run: |
          kubectl create secret docker-registry acr-auth \
            --docker-server=${{ secrets.ACR_LOGIN_SERVER }} \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace=$STAGING_NAMESPACE

      # -------------------------------
      # Update image tags in YAML files
      # -------------------------------
      - name: Update Image Tags
        run: |
          # First apply the YAML files
          kubectl apply -f k8s/product-service.yaml -n $STAGING_NAMESPACE
          kubectl apply -f k8s/order-service.yaml -n $STAGING_NAMESPACE
          kubectl apply -f k8s/customer-service.yaml -n $STAGING_NAMESPACE

          # Then update images using kubectl set image
          kubectl set image deployment/product-service-w10-aks \
            product-service-container=${{ secrets.ACR_LOGIN_SERVER }}/product_service:${{ env.IMAGE_TAG }} \
            -n $STAGING_NAMESPACE

          kubectl set image deployment/order-service-w10-aks \
            order-service-container=${{ secrets.ACR_LOGIN_SERVER }}/order_service:${{ env.IMAGE_TAG }} \
            -n $STAGING_NAMESPACE

          kubectl set image deployment/customer-service-w10-aks \
            customer-service-container=${{ secrets.ACR_LOGIN_SERVER }}/customer_service:${{ env.IMAGE_TAG }} \
            -n $STAGING_NAMESPACE

          # Verify the updates
          echo "üîç Verifying deployment images:"
          kubectl get deployments -n $STAGING_NAMESPACE -o=jsonpath='{range .items[*]}{"\n"}{.metadata.name}{":\n"}{range .spec.template.spec.containers[*]}{.name}{" -> "}{.image}{"\n"}{end}{end}'

      # -------------------------------
      # Update service types for staging (ClusterIP instead of LoadBalancer)
      # -------------------------------
      - name: Update Service Types for Staging
        run: |
          # Change LoadBalancer to ClusterIP for staging
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/product-service.yaml
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/order-service.yaml  
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/customer-service.yaml
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/frontend.yaml

      - name: Apply ConfigMaps
        run: kubectl apply -f k8s/configmaps.yaml -n $STAGING_NAMESPACE

      - name: Apply Secrets
        run: kubectl apply -f k8s/secrets.yaml -n $STAGING_NAMESPACE

      # -------------------------------
      # Deploy Databases
      # -------------------------------
      - name: Deploy Product DB
        run: |
          kubectl apply -f k8s/product-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/product-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Order DB
        run: |
          kubectl apply -f k8s/order-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/order-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Customer DB
        run: |
          kubectl apply -f k8s/customer-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/customer-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Deploy Backend Services using YAML files
      # -------------------------------
      - name: Deploy Product Service
        run: |
          kubectl apply -f k8s/product-service.yaml -n $STAGING_NAMESPACE

          # Debug pod status
          echo "üîç Checking pod status..."
          kubectl get pods -n $STAGING_NAMESPACE -l app=product-service

          # Get detailed pod description
          echo "üìã Pod description:"
          kubectl describe pods -n $STAGING_NAMESPACE -l app=product-service

          # Wait for rollout
          kubectl rollout status deployment/product-service-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Order Service
        run: |
          kubectl apply -f k8s/order-service.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/order-service-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Customer Service
        run: |
          kubectl apply -f k8s/customer-service.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/customer-service-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Inject Service URLs into Frontend
      # -------------------------------
      - name: Inject Service URLs into Frontend
        run: |
          FRONTEND_FILE=frontend/main.js

          # For staging, use ClusterIP with correct service names
          PRODUCT_API_IP="http://$(kubectl get svc product-service-w10-aks -n $STAGING_NAMESPACE -o jsonpath='{.spec.clusterIP}'):8000"
          ORDER_API_IP="http://$(kubectl get svc order-service-w10-aks -n $STAGING_NAMESPACE -o jsonpath='{.spec.clusterIP}'):8000"
          CUSTOMER_API_IP="http://$(kubectl get svc customer-service-w10-aks -n $STAGING_NAMESPACE -o jsonpath='{.spec.clusterIP}'):8000"

          echo "Injecting URLs into frontend:"
          echo "Product API: $PRODUCT_API_IP"
          echo "Order API: $ORDER_API_IP"
          echo "Customer API: $CUSTOMER_API_IP"

          # Replace placeholders safely
          sed -i "s|_PRODUCT_API_URL_|${PRODUCT_API_IP}|g" "$FRONTEND_FILE"
          sed -i "s|_ORDER_API_URL_|${ORDER_API_IP}|g" "$FRONTEND_FILE"
          sed -i "s|_CUSTOMER_API_URL_|${CUSTOMER_API_IP}|g" "$FRONTEND_FILE"

          # Verify the replacement worked
          echo "Verifying URL injection:"
          grep -n "http://" "$FRONTEND_FILE" || echo "No HTTP URLs found in frontend file"

      - name: Login to ACR
        run: |
          echo ${{ secrets.ACR_PASSWORD }} | docker login -u ${{ secrets.ACR_USERNAME }} --password-stdin ${{ secrets.ACR_LOGIN_SERVER }}

      - name: Build and push frontend image
        run: |
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }} frontend
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }}

      - name: Deploy Frontend
        run: |
          # Apply frontend deployment with initial debug info
          echo "üöÄ Deploying frontend..."
          kubectl apply -f k8s/frontend.yaml -n $STAGING_NAMESPACE

          # Quick status check
          echo "‚è≥ Initial pod status (5s)..."
          sleep 5
          kubectl get pods -n $STAGING_NAMESPACE -l app=frontend

          # Check events for potential issues
          echo "üìã Checking events..."
          kubectl get events -n $STAGING_NAMESPACE --sort-by='.lastTimestamp' | grep frontend

          # Debug pod status with shorter timeout
          echo "üîç Watching pod status..."
          timeout 60s kubectl get pods -n $STAGING_NAMESPACE -l app=frontend -w || true

          # Get detailed pod description if any exist
          POD_NAME=$(kubectl get pods -n $STAGING_NAMESPACE -l app=frontend -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
          if [ ! -z "$POD_NAME" ]; then
            echo "üìù Pod description:"
            kubectl describe pod $POD_NAME -n $STAGING_NAMESPACE
          fi

          # Final rollout check
          echo "‚è≥ Waiting for rollout completion..."
          kubectl rollout status deployment/frontend-w10-aks -n $STAGING_NAMESPACE --timeout=60s

          # Verify final state
          echo "‚úÖ Final deployment state:"
          kubectl get deployment,pods -n $STAGING_NAMESPACE -l app=frontend

      - name: Log Service Status
        run: |
          echo "üåê Checking service status in namespace $STAGING_NAMESPACE..."
          kubectl get svc -n $STAGING_NAMESPACE

          # Updated service names to match -w10-aks suffix
          for svc in frontend-w10-aks product-service-w10-aks order-service-w10-aks customer-service-w10-aks; do
            TYPE=$(kubectl get svc $svc -n $STAGING_NAMESPACE -o jsonpath='{.spec.type}' 2>/dev/null || echo "NotFound")
            if [ "$TYPE" = "LoadBalancer" ]; then
              EXTERNAL_IP=$(kubectl get svc $svc -n $STAGING_NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              echo "‚úÖ $svc LoadBalancer IP: $EXTERNAL_IP"
            else
              echo "‚ÑπÔ∏è $svc is $TYPE"
            fi
          done

      - name: Run Staging Tests
        run: |
          echo "üß™ Running staging tests..."

          # Test frontend with correct service name
          kubectl port-forward service/frontend-w10-aks -n $STAGING_NAMESPACE 8080:80 &
          PF_PID=$!
          sleep 10

          if curl -f -s --max-time 10 http://localhost:8080 >/dev/null; then
            echo "‚úÖ Frontend responding"
          else
            echo "‚ùå Frontend not responding"
          fi

          kill $PF_PID 2>/dev/null || true

          # Verify all pods are ready with correct service names
          for svc in customer-service-w10-aks order-service-w10-aks product-service-w10-aks frontend-w10-aks; do
            POD_COUNT=$(kubectl get pods -n $STAGING_NAMESPACE -l app=${svc%-w10-aks} --field-selector=status.phase=Running | grep -c ${svc%-w10-aks} || echo "0")
            if [ "$POD_COUNT" -gt 0 ]; then
              echo "‚úÖ $svc pods running: $POD_COUNT"
            else
              echo "‚ö†Ô∏è No running pods found for $svc"
            fi
          done

      - name: Display Staging Status
        run: |
          echo "üìã Staging deployment summary for namespace: $STAGING_NAMESPACE"
          kubectl get services -n $STAGING_NAMESPACE
          kubectl get deployments -n $STAGING_NAMESPACE
          kubectl get pods -n $STAGING_NAMESPACE

      - name: Cleanup Staging Environment
        if: always()
        run: |
          echo "üßπ Cleaning up staging environment..."
          kubectl delete namespace $STAGING_NAMESPACE --ignore-not-found=true --timeout=60s
          echo "‚úÖ Staging cleaned up"
