name: Stage 2 - Staging Deployment

on:
  workflow_run:
    workflows: ["CI Pipeline - Testing Branch"]
    types:
      - completed
    branches:
      - testing

jobs:
  staging-deployment:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    env:
      RESOURCE_GROUP: teddysit722Week10
      AKS_NAME: aksteddy722Week10
      ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
      IMAGE_TAG: ${{ github.event.workflow_run.head_sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Connect to AKS
        run: |
          az aks get-credentials --resource-group $RESOURCE_GROUP --name $AKS_NAME
          kubectl cluster-info

      - name: Create Staging Namespace
        run: |
          STAGING_NAMESPACE="staging-${{ github.run_id }}"
          kubectl create namespace $STAGING_NAMESPACE || echo "Namespace exists"
          echo "STAGING_NAMESPACE=$STAGING_NAMESPACE" >> $GITHUB_ENV

      - name: Create ACR Pull Secret
        run: |
          kubectl create secret docker-registry acr-auth \
            --docker-server=${{ secrets.ACR_LOGIN_SERVER }} \
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            --namespace=$STAGING_NAMESPACE

      # -------------------------------
      # Update service types for staging (ClusterIP)
      # -------------------------------
      - name: Update Service Types for Staging
        run: |
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/product-service.yaml
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/order-service.yaml  
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/customer-service.yaml
          sed -i 's/type: LoadBalancer/type: ClusterIP/g' k8s/frontend.yaml

      - name: Apply ConfigMaps
        run: kubectl apply -f k8s/configmaps.yaml -n $STAGING_NAMESPACE

      - name: Apply Secrets
        run: kubectl apply -f k8s/secrets.yaml -n $STAGING_NAMESPACE

      # -------------------------------
      # Deploy Databases
      # -------------------------------
      - name: Deploy Product DB
        run: |
          kubectl apply -f k8s/product-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/product-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Order DB
        run: |
          kubectl apply -f k8s/order-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/order-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Customer DB
        run: |
          kubectl apply -f k8s/customer-db.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/customer-db-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Deploy RabbitMQ
      # -------------------------------
      - name: Deploy RabbitMQ
        run: |
          kubectl apply -f k8s/rabbitmq.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/rabbitmq-deployment-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Deploy Backend Services
      # -------------------------------
      - name: Deploy Product Service
        run: |
          kubectl apply -f k8s/product-service.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/product-service-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Order Service
        run: |
          kubectl apply -f k8s/order-service.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/order-service-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      - name: Deploy Customer Service
        run: |
          kubectl apply -f k8s/customer-service.yaml -n $STAGING_NAMESPACE
          kubectl rollout status deployment/customer-service-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Deploy Frontend
      # -------------------------------
      - name: Inject Backend IPs for Local Testing
        run: |
          FRONTEND_FILE=frontend/main.js
          sed -i "s|_PRODUCT_API_URL_|http://localhost:18000|g" "$FRONTEND_FILE"
          sed -i "s|_ORDER_API_URL_|http://localhost:18001|g" "$FRONTEND_FILE"
          sed -i "s|_CUSTOMER_API_URL_|http://localhost:18002|g" "$FRONTEND_FILE"

      - name: Login to ACR
        run: |
          echo ${{ secrets.ACR_PASSWORD }} | docker login -u ${{ secrets.ACR_USERNAME }} --password-stdin ${{ secrets.ACR_LOGIN_SERVER }}

      - name: Build and Push Frontend Image
        run: |
          docker build -t ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }} frontend
          docker push ${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }}

      - name: Update Frontend Deployment
        run: |
          kubectl apply -f k8s/frontend.yaml -n $STAGING_NAMESPACE
          kubectl set image deployment/frontend-w10-aks \
            frontend-container=${{ secrets.ACR_LOGIN_SERVER }}/frontend:${{ env.IMAGE_TAG }} \
            -n $STAGING_NAMESPACE
          kubectl rollout status deployment/frontend-w10-aks -n $STAGING_NAMESPACE --timeout=300s

      # -------------------------------
      # Wait for Services, Port Forward, and Debug Logs
      # -------------------------------
      - name: Wait for Services and Setup Port Forwarding with Logs
        run: |
          NAMESPACE=$STAGING_NAMESPACE
          POD_LABELS=("product-service" "order-service" "customer-service" "frontend")
          SERVICES=("product-service-w10-aks" "order-service-w10-aks" "customer-service-w10-aks" "frontend-w10-aks")
          LOCAL_PORTS=(18000 18001 18002 18003)
          TARGET_PORTS=(8000 8001 8002 80)

          # Wait for pods and print logs
          for label in "${POD_LABELS[@]}"; do
            echo "üîç Waiting for pods with label app=$label to be ready..."
            kubectl wait --for=condition=Ready pod -l app=$label -n $NAMESPACE --timeout=300s || true
            echo "üìÑ Pods for $label:"
            kubectl get pods -l app=$label -n $NAMESPACE
            echo "üìù Last 20 lines of logs for $label:"
            for pod in $(kubectl get pods -l app=$label -n $NAMESPACE -o jsonpath='{.items[*].metadata.name}'); do
              echo "--- Logs for $pod ---"
              kubectl logs $pod -n $NAMESPACE --tail=20
            done
          done

          # List services
          echo "üìÑ Services in namespace $NAMESPACE:"
          kubectl get svc -n $NAMESPACE

          # Kill any existing port forwards
          pkill -f "kubectl port-forward" || true
          sleep 2

          # Setup port forwards with correct mappings
          for i in ${!SERVICES[@]}; do
            svc=${SERVICES[$i]}
            local_port=${LOCAL_PORTS[$i]}
            target_port=${TARGET_PORTS[$i]}
            echo "üöÄ Port-forward $svc: localhost:$local_port -> $target_port"
            kubectl port-forward svc/$svc $local_port:$target_port -n $NAMESPACE --address=127.0.0.1 &
            sleep 1  # Small delay between port forwards
          done

          echo "‚è≥ Waiting 20s for port forwards to stabilize..."
          sleep 20

      # -------------------------------
      # Test Service Connectivity
      # -------------------------------
      - name: Test Service Connectivity
        run: |
          test_endpoint() {
            local name=$1
            local url=$2
            local expected_response=${3:-""}
            
            echo "üîç Testing $name at $url"
            
            for i in {1..15}; do
              if curl -f -s --max-time 10 "$url" >/dev/null 2>&1; then
                echo "‚úÖ $name is responding"
                return 0
              else
                echo "‚è≥ Attempt $i/15: $name not ready, retrying..."
                sleep 3
              fi
            done
            
            echo "‚ùå $name failed to respond after 15 attempts"
            echo "üîç Debug: Checking if port forward is active..."
            netstat -tlnp | grep ":$(echo $url | cut -d: -f3 | cut -d/ -f1)" || echo "Port not found in netstat"
            return 1
          }

          # Test basic connectivity first (root endpoints)
          test_endpoint "Product Service" "http://localhost:18000/"
          test_endpoint "Order Service" "http://localhost:18001/"  
          test_endpoint "Customer Service" "http://localhost:18002/"
          test_endpoint "Frontend" "http://localhost:18003/"

          # If basic connectivity works, try health endpoints
          echo "üîç Testing health endpoints..."
          curl -f -s --max-time 5 "http://localhost:18000/health" && echo "‚úÖ Product Service health OK" || echo "‚ö†Ô∏è Product Service health endpoint not available"
          curl -f -s --max-time 5 "http://localhost:18001/health" && echo "‚úÖ Order Service health OK" || echo "‚ö†Ô∏è Order Service health endpoint not available"
          curl -f -s --max-time 5 "http://localhost:18002/health" && echo "‚úÖ Customer Service health OK" || echo "‚ö†Ô∏è Customer Service health endpoint not available"

      # -------------------------------
      # Additional Debugging
      # -------------------------------
      - name: Debug Service Status
        if: failure()
        run: |
          echo "üîç Debugging failed connectivity..."

          # Check pod status
          echo "üìÑ Pod status:"
          kubectl get pods -n $STAGING_NAMESPACE

          # Check service endpoints
          echo "üìÑ Service endpoints:"
          kubectl get endpoints -n $STAGING_NAMESPACE

          # Check port forwards
          echo "üìÑ Active port forwards:"
          ps aux | grep "kubectl port-forward" || echo "No port forwards found"

          # Test internal service connectivity
          echo "üìÑ Testing internal service connectivity:"
          kubectl run test-pod --image=curlimages/curl:latest --rm -i --restart=Never -n $STAGING_NAMESPACE -- curl -f -s --max-time 5 http://product-service-w10-aks:8000/ || echo "Product service internal test failed"

      # -------------------------------
      # Cleanup Port Forwards
      # -------------------------------
      # - name: Cleanup Port Forwards
      #   if: always()
      #   run: |
      #     echo "üßπ Cleaning up port forwards..."
      #     pkill -f "kubectl port-forward" || true
